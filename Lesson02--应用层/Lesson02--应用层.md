# 2. 应用层

## 2.1 网络应用原理

### 2.1.1 网络应用体系结构

**应用体系结构(application architecture)** 由应用程序研发者设计,规定了如何在各种端系统上组织该应用程序.

两种主流体系结构:客户-服务器体系结构或对等(P2P)体系结构.

在 **客户-服务器体系结构(client-server architecture)** 中,有一个总是打开的主机,称为服务器,他服务于来自许多其它称为客户的主机的请求.

在 **P2P体系结构(P2P architecture)** 中,对位于数据中心的专用服务器有最小的(或者没有)依赖.

### 2.1.2 进程通信

进行通信的实际上是 **进程(process)** 而不是程序.

1. 客户和服务器进程
   对每对通信进程,我们通常将这两个进程之一标识为 **客户(client)** ,而另一个进程标识为 **服务器(server)** .
2. 进程与计算机网络之间的接口
   进程通过一个称为 **套接字(socket)** 的软件接口向网络发送报文和从网络接收报文.
   套接字是同一台主机内应用层与运输层之间的接口.套接字也称为应用程序和网络之间的 **应用编程接口(Application Programming Interface,API).
3. 进程寻址
   在一台主机上运行的进程为了向另一台主机上运行的进程发送分组,接收进程需要有一个地址.为了标识该接收进程,需要定义两种信息:主机的地址,在目的主机中指定接收进程的标识符.
   在因特网中,主机由其 **IP地址(IP address)** 标识.
   目的地 **端口号(port number)** 用于指定运行在接受主机上的接收进程.

### 2.1.3 可供应用程序使用的运输服务

1. 可靠数据传输
2. 吞吐量
3. 定时
4. 安全性

### 2.1.4 因特网提供的运输服务

1. TCP服务
   TCP服务模型包括面向连接服务和可靠数据传输服务.
   * 面向连接的服务:在应用层数据报文开始流动之前,TCP让客户和服务器相互交换运输层控制信息.这个所谓的握手过程提醒客户和服务器,让它们为大量分组的到来做好准备.在握手阶段后,一个 **TCP连接(TCP connection)** 就在两个进程的套接字之间建立了.这条连接是全双工的,即连接双方的进程可以在此连接上同时进行报文收发.
   * 可靠的数据传输服务:通信进程能够依靠TCP,无差错,按适当顺序交付所有发送的数据.当应用程序的一端将字节流传进套接字时,它能够依靠TCP将相同的字节流交付该接收方的套接字,而没有字节的丢失和冗余.  
  > 无论是TCP还是UDP都没有提供任何加密机制,这就是说发送进程传进其套接字的数据,与网络传送到目的进程的数据相同.  
  > 因特网界已经研制了TCP的加强版本,称为 **运输层安全(Transport Layer Security,TLS)[RFC 5246]** .
2. UDP服务
   UDP是一种不提供不必要服务的轻量级运输协议,它仅提供最低限度的服务.UDP是无连接的,因此在两个进程通信前没有握手过程.UDP提供一种不可靠数据传输服务,也就是说当进程将一个报文发送进UDP套接字时,UDP并不保证该报文将到达接收进程.不仅如此,到达接收进程的报文也可能是乱序到达的.
3. 因特网运输协议所不提供的服务
   因特网通常能够为时间敏感应用提供满意的服务,但它不能提供任何定时或吞吐量的保证.

| 应用         | 应用层协议                  | 支撑的运输协议 |
| ------------ | --------------------------- | -------------- |
| 电子邮件     | SMTP[RFC 5321]              | TCP            |
| 远程终端访问 | Telnet[RFC 854]             | TCP            |
| Web          | HTTP[RFC 7230]              | TCP            |
| 文件传输     | FTP[RFC 959]                | TCP            |
| 流式多媒体   | HTTP,DASH                   | TCP            |
| 因特网电话   | SIP[RFC 3261],RTP[RFC 3550] | UDP或TCP       |

### 2.1.5 应用层协议

**应用层协议(application-layer protocal)** 定义了运行在不同端系统上的应用程序进程如何相互传递报文.特别是,应用层协议定义了以下内容:
* 交换点报文类型,例如请求报文和响应报文.
* 各种报文类型的语法,如报文中的各个字段及这些字段是如何描述的.
* 字段的语义,即这些字段中信息的含义.
* 确定一个进程何时以及如何发送报文,对报文进行响应的规则.

## 2.2 Web和HTTP

### 2.2.1 HTTP概述

Web的应用层协议是 **超文本传输协议(HyperText Transfer Protocol,HTTP)** ,它是Web的核心.HTTP由两个程序实现:一个客户程序和一个服务器程序.

**Web页面(Web page)** 是由对象组成的.一个 **对象(object)** 只是一个文件,诸如一个HTML文件,一个JEPG图形,一个JavaScript文件,一个CCS样式表文件或一个视频片段,它们可以通过一个URL寻址.

多数Web页面含有一个 **HTML基本文件(base HTML file)** 及几个引用对象.

每个URL由两部分组成:存放对象的服务器主机名和对象的路径名.

HTTP定义了Web客户向Web服务器请求Web页面的方式,以及服务器向客户传送Web页面的方式.

服务器向客户发送被请求的文件,而不存储任何关于该客户的状态信息.假如某个特定的客户在短短的几秒内两次请求同一个对象,服务器并不会因为刚刚为该客户提供了该对象就不再做出反应,而是重新发送该对象.因为服务器并不保存关于客户的任何信息,所以我们说HTTP是一个 **无状态协议(stateless protocol)** .

### 2.2.2 非持续连接和持续连接

**非持续链接(non-persistent connection)** :每个请求/响应对是经一个单独的TCP连接发送.
**持续连接(persistent connection)** :所有的请求及其响应经相同的TCP连接发送.

1. 采用非持续连接的HTTP
   假设服务器向客户传送一个含有一个HTML基本文件和10个JPEG图形的Web文件.
   1. HTTP客户进程在端口号80发起一个到服务器的TCP连接.
   2. HTTP客户经它的套接字向该服务器发送一个HTTP请求报文.
   3. HTTP服务器进程经它的套接字接收该请求报文,从其存储器中检索出对象,在一个HTTP响应报文中封装对象,并通过套接字向客户发送响应报文.
   4. HTTP服务器进程通知TCP断开该TCP连接.
   5. HTTP客户接收响应报文,TCP连接关闭.该报文指出封装的对象是一个HTML文件,客户从响应报文中提取出该文件,检查该HTML文件,得到对10个JPRG图形的引用.
   6. 对每个引用的JPEG图形重复前4个步骤.
2. 采用持续连接的HTTP
   在采用HTTP1.1持续连接的情况下,服务器在发送响应后保持该TCP连接打开.在相同的客户与服务器之间,后续的请求和响应报文能够通过相同的连接进行传送.

### 2.2.3 HTTP报文格式

HTTP规范[RFC 1954;RFC 7230;RFC 7540]包含了对HTTP报文格式的定义.

HTTP报文有两种:请求报文和响应报文.

1. HTTP请求报文
   一个典型的HTTP请求报文:
   ```
   GET /somedir/page.html HTTP/1.1
   Host: www.someschool.edu
   Connection: close
   User-agent: Mozilla/5.0
   Accept-lauguage: fr

   ```
   一个请求报文能够具有更多的行或至少为一行.
   一个额外的换行回车符表示报文结束.
   HTTP请求报文的第一行叫作 **请求行(request line)** 其后继的行叫作 **首部行(header line)** .
   请求行有3个字段:方法字段,URL字段,HTTP版本字段.
   HTTP请求方法:
   | 方法   | 描述                                                                                                                                   |
   | ------ | -------------------------------------------------------------------------------------------------------------------------------------- |
   | GET    | 请求指定的页面信息,并返回实体主体.                                                                                                     |
   | HEAD   | 类似于 `GET` 请求,只不过返回的响应中没有具体的内容,用于获取报头.                                                                       |
   | POST   | 向指定资源提交数据进行处理请求(例如提交表单或者上传文件).数据被包含在请求体中. `POST` 请求可能会导致新的资源的建立和/或已有资源的修改. |
   | PUT    | 从客户端向服务器传送的数据取代指定的文档的内容.                                                                                        |
   | DELETE | 请求服务器删除指定的页面.                                                                                                              |

   绝大部分的HTTP请求报文使用GET方法.
   首部行 `Host: www.someschool.edu` 指明了对象所在的主机.该首部行提供的信息是Web代理高速缓存所要求的.
   通过包含 `Connection: close` 首部行,该浏览器告诉服务器不要麻烦地使用持续连接,它要求服务器在发送完被请求的对象后就关闭这条连接.
   `User-agent:` 用来指明用户代理,即向服务器发送请求的浏览器类型.这里的 `Mozilla/5.0` 即 `Fire-fox` 浏览器.
   `Accept-language: fr` 表示用户想得到该对象的法语版本,否则服务器发送它的默认版本.
   ![](2.2.3-a.svg)
2. HTTP响应报文
   ```
   HTTP/1.1 200 OK
   Connection: close
   Date: Tue, 18 Aug 2015 15:44:04 GMT
   Server: Apache/2.2.3(CentOS)
   Last-Modified: Tue
   ```
   ![](2.2.3-b.svg)
   常见状态码:
   * 200 OK
   * 301 Moved Permanently
   * 400 Bad Request
   * 404 Not Found
   * 505 HTTP Version Not Supported

### 2.2.4 用户与服务器的交互:cookie

HTTP服务器是无状态的.这简化了服务器的设计,并允许工程师取开发可以同时处理数千个TCP连接的高性能服务器.然而一个Web站点通常希望能够识别用户,可能是因为服务器希望限制用户的访问,或者因为它希望把内容与用户身份联系起来.为此,HTTP使用了 *cookie* . *cookie* 在[RFC 6265] 中定义,它允许站点对用户进行跟踪.

### 2.2.5 Web缓存(代理服务器)

目标:不访问原始服务器,就满足客户的请求.

**Web缓存器(Web cache)** 也叫 **代理服务器(proxy server)** ,它是能够代表初始Web服务器来满足HTTP请求的网络实体.

Web缓存器有自己的磁盘存储空间,并在存储空间中保存最近请求过的对象的副本.

1. 浏览器创建一个到Web缓存器的TCP连接,并向Web缓存器中的对象发送一个HTTP请求.
2. Web缓存器进行检查,看看本地是否存储了该对象的副本.如果有,Web缓存器就向客户浏览器用HTTP响应报文返回该对象.
3. 如果Web缓存器中没有该对象,它就打开一个与该对象的初始服务器的TCP连接.Web缓存器则在这个缓存器到服务器的TCP连接上发送一个对该对象的HTTP请求.在收到该请求后,初始服务器向该Web缓存器发送具有该对象的HTTP响应.
4. 当Web缓存器接收到该对象时,它在本地存储空间存储一份副本,并向客户的浏览器用HTTP响应报文发送该副本.

Web缓存器既是服务器也是客户.Web缓存器通常由ISP购买并安装.

通过使用 **内容分发网络(Content Distribution Network,CDN)** ,Web缓存器正在因特网中发挥着越来越重要的作用.

**条件GET方法**
高速缓存能减少用户感受到的响应时间,但存放在缓存器中的对象副本可能是陈旧的.  
HTTP有一种机制,允许缓存器证实它的对象是最新的.这种机制就是 **条件GET(conditional GET)[RFC 7232]** .  
如果HTTP请求报文使用GET方法,并且请求报文中包含一个"If-modified-since:"首部行,那么,这个HTTP请求报文就是一个条件GET请求报文.

### 2.2.6 HTTP/2

1. HTTP/2成帧
2. 响应报文的优先次序和服务器推
3. HTTP/3

## 2.3 因特网中的电子邮件

3个主要组成部分: **用户代理(user agent)** , **邮件服务器(mail server)** , **简单邮件传输协议(Simple Mail Transfer Protocol,SMTP)** .

邮件服务器形成了电子邮件体系结构的核心.每个接收方在其中的某个邮件服务器上有一个 **邮箱(mailbox)** .

SMTP是因特网电子邮件中主要的应用层协议.它使用TCP可靠数据传输凡服务.

### 2.3.1 SMTP

### 2.3.2 邮件报文格式

### 2.3.3 邮件访问协议

## 2.4 DNS:因特网的目录服务

主机的一种标识方式是用 **主机名(hostname)** ,如 `www.facebook.com` , `www.google.com` 等.主机名可能由不定长的字母数字组成,路由器难以处理.为此,主机也可以使用所谓的 **IP(IP address)** 进行标识.

一个IP地址由4个字节组成,并有着严格的层次结构.

### 2.4.1 DNS提供的服务

识别主机有两种方式:主机名,IP地址.

人们喜欢记忆主机名的标识方式,而路由器喜欢定长的,有层次结构的IP地址.

为了对不同的偏好折中,我们需要一种能进行主机名到IP地址转换的目录服务.这就是 **域名系统(Domain Name System,DNS)** 的主要任务.

DNS是:
1. 一个由分层的 **DNS服务器(DNS server)** 实现的分布式数据库.
2. 一个使得主机能够查询分布式数据库的应用层协议.

DNS服务器通常是运行 **BIND(Berkeley Internet Name Domain)** 软件[BIND 2020]的UNIX机器.DNS协议运行在UDP之上,使用53号端口.

运行在某用户主机上的一个浏览器请求URL页面时,为使用户的主机能够将一个HTTP请求报文发送到HTTP服务器,该用户主机必须获得服务器的IP地址.
1. 同一台用户主机上运行着DNS应用的客户端.
2. 浏览器从URL中提取到主机名,并将主机名传给DNS应用的客户端.
3. DNS客户向DNS服务器发送一个包含主机名的请求.
4. DNS客户最终会收到一份回答报文,其中含有对应于该主机名的IP地址.
5. 浏览器接收到来自DNS的该IP地址,它就向位于该IP地址80端口的HTTP服务器进程发起一个TCP连接.

除了进行主机名到IP地址的转换外,DNS还提供了一些重要的服务:
* 主机别名
* 邮件服务器别名
* 负载分配

### 2.4.2 DNS工作机理概述

1. 分布式,层次数据库
   * 根DNS服务器
   * 顶级域(TLD)DNS服务器
   * 权威DNS服务器
2. DNS缓存

### 2.4.3 DNS记录和报文

1. DNS报文
2. 在DNS数据库中插入记录

## 2.5 P2P文件分发

1. P2P体系结构的扩展性
2. BitTorrent
   BitTorrent是一种用于文件分发的流行P2P协议[Chao 2011].用BitTorrent的术语来讲,参与一个特定文件分发的所有对等方的集合被称为一个洪流(torrent).在一个洪流中的对等方彼此下载等长度的文件快(chunk),典型的块长度为256KB.

## 2.6 视频流和内容分发网

### 2.6.1 因特网视频

### 2.6.2 HTTP流和DASH

### 2.6.3 内容分发网

1. CDN操作
2. 集群选择策略

## 2.7 套接字编程

### 2.7.1 UDP套接字编程

### 2.7.2 TCP套接字编程